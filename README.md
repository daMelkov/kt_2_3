### Задача №1 - Посты (без Attachments)
Мы с вами изучили `Nullable`, поэтому пришло время закрыть вопросы с постами: привыкайте к тому, что ваш код никуда не исчезает, и вам предстоит поддерживать то, что вы сами же когда-то написали (старая шутка "да кто вообще это писал?"). Поэтому мы в том числе будем отрабатывать и этот навык.

Доработайте первую задачу из предыдущей лекции так, чтобы ваша система отображала все поля объекта (кроме `attachments`), описанного в документации.

Что мы хотим получить:
1. Data класс `Post`
2. Внутри `Post` могут быть `Nullable` свойства
3. `WallService`, который внутри себя хранит посты в массиве

Итого: у вас должен быть репозиторий на GitHub, в котором расположен ваш Gradle-проект (автотесты также должны храниться в репозитории).

### Задача №2 - Attachments
Надеемся, что с постами было не так уж и сложно. А вот с `attachments` будет сложнее.

Почему? Потому что у вас в массиве будут храниться совершенно разные объекты (на самом деле не совсем так, но сейчас разберёмся).

Сам Vk их хранит вот так:
```json
{
  "attachments": [
    {
      "type": "photo",
      "photo": {
        "id": 1,
        "album_id": 1,
        "owner_id": 1,
        "user_id": 1
      }
    }, {
      "type": "video",
      "video": {
        "id": 1,
        "album_id": 1,
        "owner_id": 1,
        "user_id": 1
      }
    }
  ]
}
```
Что это значит? Это значит, что у вас есть объект типа `Attachment`, в котором есть поле `type`, а вот какое второе поле у него есть - мы не знаем (оно определяется на базе значения поля `type`).

Соответственно, у вас два варианта:
1. Сделать `Attachment` интерфейсом
2. Сделать `Attachment` абстрактным классом

Тогда всё сходится и вы можете создать массив типа `Attachment` и через Smart Casts работать уже работать с конкретным полем.

Собственно, это вам и необходимо сделать.

Поскольку типов вложений очень много, вам достаточно выбрать для реализации любые 5.

Важно: после ваших обновлений, функциональность `WallService` должна оставаться работоспособной (т.е. автотесты должны проходить).

### Задача №3 - Sealed классы*

Одной из возможностей Kotlin для решения предыдущей задачи являются [Sealed ("запечатанные") классы](https://kotlinlang.org/docs/reference/sealed-classes.html).

Что это значит? Это значит, что вы можете определить фиксированную иерархию типов (ведь количество типов вложений у вас фиксировано).

Тогда в выражениях типа `when` вам не придётся писать `else`.

Нужно почитать [документацию](https://kotlinlang.org/docs/reference/sealed-classes.html) и сделать Pull Request с реализацией на базе Sealed классов.

<<<<<<< HEAD
Важно: после ваших обновлений, функциональность `WallService` должна оставаться работоспособной (т.е. автотесты должны проходить).
=======
- на `add` - всего один, который проверяет, что после добавления поста `id` стал не равным 0
- на `update` - целых два:
    - удаляем пост с существующим `id`, возвращается `true`
    - удаляем пост с несуществующим `id`, возвращается `false`
>>>>>>> parent of b033fb1... fix readme
